#!/usr/bin/env python3

"""
jobinfo

View detailed job information

This script requires:
  - Python 3.10+ (for the zip() strict = True option)
  - Slurm 23.02+ (for the sacct field "planned")
  - Slurm configured with:
    - Job accounting (required): JobAcctGatherType=jobacct_gather/linux or jobacct_gather/cgroup
    - GPU gres (optional): GresTypes=gpu
    - GPU accounting (optional): AccountingStorageTRES=gres/gpu

Notes:
  - Based on output from sacct, squeue, and sstat
  - Starting with Slurm 23.02, the sacct field "reserved" was renamed to "planned"
"""

import argparse
import math
import os
import re
import subprocess
import sys

# Set up arguments and options
parser = argparse.ArgumentParser(
    prog = "jobinfo",
    formatter_class = argparse.RawDescriptionHelpFormatter,
    description = "View detailed job information",
    epilog = """\
examples:

jobinfo 123456
jobinfo $SLURM_JOB_ID

notes:

to find job IDs, run jobhist

support:

https://github.com/uschpc/slurm-tools/issues"""
)
parser.add_argument(
    "jobid",
    nargs = "?",
    help = "job ID to query"
)
parser.add_argument(
    "-V",
    "--version",
    action = "store_true",
    help = "print version"
)
args = parser.parse_args()

if args.version:
    print("jobinfo 2.2.0")
    sys.exit(0)

if not args.jobid:
    print("Error: no job ID provided", file = sys.stderr)
    print("Usage: jobinfo [-h] [-V] [jobid]", file = sys.stderr)
    print("To find job IDs, run jobhist", file = sys.stderr)
    sys.exit(1)

if re.search(r",", args.jobid):
    print("Error: only one job ID is accepted", file = sys.stderr)
    print("Usage: jobinfo [-h] [-V] [jobid]", file = sys.stderr)
    sys.exit(1)

# Define utility functions

def parsetime(x):
    """
    Parse time elements from string

    # Arguments
    - x (str): sacct value for time

    # Returns
    - tuple: days, hours, minutes, seconds

    # Notes
    - Slurm time format is dd-hh:mm:ss.sss
    - Value will at least include mm:ss
    """
    m = re.match(r"(((?P<days>\d+)-)?(?P<hours>\d\d):)?"
                 + r"(?P<minutes>\d\d):(?P<seconds>\d\d(\.\d+)?)", x)
    if not m:
        return 0, 0, 0, 0.0
    dd = int(m.group("days") or "0")
    hh = int(m.group("hours") or "0")
    mm = int(m.group("minutes"))
    ss = float(m.group("seconds"))
    return dd, hh, mm, ss

def toseconds(x):
    """
    Convert time to seconds

    # Arguments
    - x (str): sacct value for time

    # Returns
    - float: time in seconds
    """
    dd, hh, mm, ss = parsetime(x)
    return dd*24*60*60 + hh*60*60 + mm*60 + ss

def tobytes(x):
    """
    Convert string to bytes

    # Arguments
    - x (str): sacct or sstat value for size

    # Returns
    - float: -1.0 (if x is empty)
    - float: size in bytes
    """
    # Some values may be empty if job is RUNNING
    # Return -1.0 for comparison purposes
    if not x:
        return -1.0
    units = {"K": 10, "M": 20, "G": 30, "T": 40, "P": 50, "E": 60}
    scale = 2 ** units.get(x[-1], 0)
    if scale != 1:
        x = x[:-1]
    return float(x) * scale

# Define selector functions

def firstv(x, y):
    """
    Select first non-empty value in multi-line output

    # Arguments
    - x (str): first value to compare
    - y (str): second value to compare

    # Returns
    - str: first non-empty value
    """
    return x == "" and y or x

def uniquev(x, y):
    """
    Select all unique values in multi-line output

    # Arguments
    - x (str): first value to compare
    - y (str): second value to compare

    # Returns
    - str: unique values (separated by /)
    """
    if y in x:
        return x
    return x + "/" + y

def allv(x, y):
    """
    Select all values in multi-line output

    # Arguments
    - x (str): first value to compare
    - y (str): second value to compare

    # Returns
    - str: all values (separated by |)
    """
    if y == "":
        return x
    return x + "|" + y

def maxtime(x, y):
    """
    Select max time value in multi-line output

    # Arguments
    - x (str): first value to compare
    - y (str): second value to compare

    # Returns
    - str: max time value
    """
    if "UNLIMITED" in [x, y]:
        return "UNLIMITED"
    if x in ["", "INVALID"]:
        return y
    if y in ["", "INVALID"]:
        return x
    return max(x, y)

def selectv(lines, selectors):
    """
    Select sacct or sstat values from multi-line output

    # Arguments
    - lines (list): one list of parsed values per line of output
    - selectors (list): selector functions

    # Returns
    - list: selected sacct or sstat values
    """
    # Extract first line of values
    vals = lines[0]
    # If more lines, run selector functions
    for line in lines[1:]:
        for i, selector in enumerate(selectors):
            vals[i] = selector(vals[i], line[i])
    return vals

# Define formatting functions

def fmtbytes(x):
    """
    Format bytes

    # Arguments
    - x (float): size in bytes

    # Returns
    - str: formatted size with units
    """
    units = " KMGTPE"
    e = int(math.log(x + 1, 2) / 10)
    return f"{x / 2 ** (e * 10):.2f}" + units[e].strip()

def fmttasks(x):
    """
    Format tasks

    # Arguments
    - x (str): sacct value for ntasks

    # Returns
    - str: "--" (if x is empty)
    - str: x
    """
    # Value is empty if job is PENDING
    if not x:
        return "--"
    return x

def fmttime(x):
    """
    Format time

    # Arguments
    - x (str): sacct value for time

    # Returns
    - str: "--" (if 0)
    - str: time formatted as (dd-)hh:mm:ss(.sss)
    """
    # Value may be 0 if job is not COMPLETED
    if x == "00:00:00":
        return "--"
    dd, hh, mm, ss = parsetime(x)
    if dd > 0:
        dd = f"{dd}-"
    else:
        dd = ""
    if str(ss).endswith(".0"):
        return f"{dd}{hh:02d}:{mm:02d}:{int(ss):02d}"
    return f"{dd}{hh:02d}:{mm:02d}:{ss:06.3f}"

def fmtdatetime(x):
    """
    Format datetime

    # Arguments
    - x (str): sacct value for datetime

    # Returns
    - str: "--" (if Unknown)
    - str: x
    """
    # Value may be Unknown if job is PENDING or RUNNING
    if x == "Unknown":
        return "--"
    return x

def fmtmaxbytes(x):
    """
    Format estimated max bytes

    # Arguments
    - x (float): estimated max bytes

    # Returns
    - str: "--" (if value is not available)
    - str: formatted bytes
    """
    # Value set to -1.0 if job not started or is RUNNING and not user or root or not found
    if x == -1.0:
        return "--"
    return f"{fmtbytes(x)} (estimate)"

# Define calculation functions

def cpueff(x, y):
    """
    Calculate CPU efficiency

    # Arguments
    - x (str): sacct value for totalcpu
    - y (str): sacct value for cputime

    # Returns
    - str: "--" (if x or y is 0)
    - str: formatted %
    """
    usedcpu = toseconds(x)
    elapsedcpu = toseconds(y)
    # Total CPU time is 0 if job not COMPLETED
    # Elapsed CPU time is 0 if job not started
    if usedcpu == 0 or elapsedcpu == 0:
        return "--"
    return f"{usedcpu / elapsedcpu * 100:5.2f}%"

def cpupct(x, y):
    """
    Calculate % of total CPU used

    # Arguments
    - x (str): sacct value for usercpu or systemcpu
    - y (str): sacct value for totalcpu

    # Returns
    - str: "--" (if y is 0)
    - str: formatted %
    """
    usedcpu = toseconds(y)
    # Total CPU time is 0 if job not COMPLETED
    if usedcpu == 0:
        return "--"
    usedsub = toseconds(x)
    return f"{usedsub / usedcpu * 100:5.2f}%"

def memeff(x, y):
    """
    Calculate memory efficiency

    # Arguments
    - x (str): estimated value for max memory used
    - y (str): sacct value for allocated memory

    # Returns
    - str: "--" (if x or y is not available)
    - str: formatted %
    """
    # Max mem set to -1.0 if job not started or is RUNNING and not user or root
    # Allocated mem set to ?? if not found
    if x == -1.0 or y == "??":
        return "--"
    allocmem = tobytes(y)
    return f"{x / allocmem * 100:5.2f}%"

# Define primary functions to get and derive job info

def getsacctv(jobid, fields):
    """
    Get sacct values and modify as needed

    # Arguments
    - jobid (str): job ID
    - fields (list): sacct fields to query and associated selector functions

    # Returns
    - dict: key-value pairs for sacct fields
    """
    keys = [item[0] for item in fields]
    fmt = ",".join(keys)
    cmd = ["sacct", "-n", "-P", "-o", fmt, "-j", jobid]
    proc = subprocess.run(cmd, capture_output = True, text = True)
    if not proc.stdout:
        print("Error: no such job", file = sys.stderr)
        sys.exit(1)
    # Job names may contain \n (causing line break)
    # Replace \n if in job name (between first | and second |)
    name = re.search(r"\|.*?\|", proc.stdout, flags = re.DOTALL)
    name2 = re.sub(r"\n", "n", name.group(0))
    name3 = re.sub(r"\|.*?\|", name2, proc.stdout, count = 1, flags = re.DOTALL)
    # Split output by line
    out = name3.split("\n")[:-1]
    # Output returned from sacct may have multiple lines
    # Jobs that are PENDING will have one line
    # Jobs that are CANCELLED or FAILED before starting will have one line
    # Otherwise, jobs that start will have multiple lines
    # Main job line, .batch or .interactive line, and .extern line
    # If srun is used, one line for each srun call
    # Select one value or combine multiple values depending on field
    # Parse values from each line into list and store in list of lists
    lines = []
    for line in out:
        spl = line.strip().split("|")
        lines.append(spl)
    # Apply selector functions to parsed output
    selectors = [item[1] for item in fields]
    vals = selectv(lines, selectors)
    # Store values in dict
    d = dict(zip(keys, vals, strict = True))
    return d

def getsqueuev(jobid):
    """
    Get squeue values and modify as needed

    # Arguments
    - jobid (str): job ID

    # Returns
    - dict: key-value pairs for squeue fields

    # Notes
    - For PENDING job
    - For job pending reason and dependencies
    """
    cmd = ["squeue", "-h", "-a", "-o", "%R|%E", "-j", jobid]
    proc = subprocess.run(cmd, capture_output = True, text = True)
    out = proc.stdout.strip().split("|")
    if out[1] == "(null)":
        out[1] = ""
    # Store values in dict
    keys = ["pdreason", "pddeps"]
    d = dict(zip(keys, out, strict = True))
    return d

def getsstatv(jobid):
    """
    Get sstat values and modify as needed

    # Arguments
    - jobid (str): job ID

    # Returns
    - dict: key-value pairs for sstat fields

    # Notes
    - For RUNNING job if user or root
    - For deriving maxmem, maxdiskread, and maxdiskwrite
    """
    fmt = "jobid,tresusageintot,tresusageouttot"
    cmd = ["sstat", "-n", "-P", "-a", "-o", fmt, "-j", jobid]
    proc = subprocess.run(cmd, capture_output = True, text = True)
    out = proc.stdout.split("\n")[:-1]
    # Output returned from sstat will have multiple lines
    # .extern line and .batch or .interactive line
    # If srun is used, one line for each srun call
    # Select one value or combine multiple values depending on field
    # Parse values from each line into list and store in list of lists
    lines = []
    for line in out:
        spl = line.strip().split("|")
        lines.append(spl)
    # Apply selector functions to parsed output (and remove job ID)
    selectors = [firstv, allv, allv]
    vals = selectv(lines, selectors)[1:]
    # Store values in dict
    keys = ["tresusageintot", "tresusageouttot"]
    d = dict(zip(keys, vals, strict = True))
    return d

def derivev(vals):
    """
    Derive other values from sacct values

    # Arguments
    - vals (dict): key-value pairs for sacct fields

    # Returns
    - dict: key-value pairs for original and derived fields
    """
    d = vals.copy()
    # Add formatted values where needed
    d["ntasksfmt"] = fmttasks(d["ntasks"])
    d["startfmt"] = fmtdatetime(d["start"])
    d["endfmt"] = fmtdatetime(d["end"])
    d["elapsedfmt"] = fmttime(d["elapsed"])
    d["cputimefmt"] = fmttime(d["cputime"])
    d["totalcpufmt"] = fmttime(d["totalcpu"])
    # Format state depending on job state
    if d["state"] == "PENDING":
        squeuev = getsqueuev(d["jobid"])
        d.update(squeuev)
        if not d["pddeps"]:
            d["statefmt"] = d["state"] + " " + d["pdreason"]
        else:
            d["statefmt"] = d["state"] + " " + d["pdreason"] + " (" + d["pddeps"] + ")"
    else:
        d["statefmt"] = d["state"]
    # Get requested nodes
    reqnodes = re.search(r"node=([0-9]+)", d["reqtres"])
    if not reqnodes:
        d["reqnodes"] = "??"
    else:
        d["reqnodes"] = reqnodes.group(1)
    # Get requested CPUs
    reqcpus = re.search(r"cpu=([0-9]+)", d["reqtres"])
    if not reqcpus:
        d["reqcpus"] = "??"
    else:
        d["reqcpus"] = reqcpus.group(1)
    # Get requested memory (may be in varying units)
    reqmem = re.search(r"mem=([0-9]+.[0-9]+[A-Z]|[0-9]+[A-Z])", d["reqtres"])
    if not reqmem:
        d["reqmem"] = "??"
    else:
        d["reqmem"] = reqmem.group(1)
    # Get requested GPUs
    reqgpus = re.search(r"gres/gpu=([0-9]+)", d["reqtres"])
    if not reqgpus:
        d["reqgpus"] = "0"
        d["reqgpumodels"] = "--"
        d["reqgpustr"] = d["reqgpus"]
    else:
        d["reqgpus"] = reqgpus.group(1)
        # Get requested GPU models (typically one but could be multiple)
        reqgpumodels = re.findall(r"gres/gpu:([a-zA-Z0-9]+)", d["reqtres"])
        if not reqgpumodels:
            d["reqgpumodels"] = "--"
            d["reqgpustr"] = d["reqgpus"]
        else:
            d["reqgpumodels"] = ",".join(reqgpumodels)
            d["reqgpustr"] = d["reqgpus"] + " (" + d["reqgpumodels"]  + ")"
    # alloctres is empty if resources have not been allocated
    # If job is PENDING or CANCELLED/FAILED before job started
    if not d["alloctres"]:
        d["allocnodes"] = "--"
        d["alloccpus"] = "--"
        d["allocmem"] = "--"
        d["allocgpus"] = "--"
        d["allocgpumodels"] = "--"
        d["allocgpustr"] = "--"
    else:
        # Get allocated nodes
        allocnodes = re.search(r"node=([0-9]+)", d["alloctres"])
        if not allocnodes:
            d["allocnodes"] = "??"
        else:
            d["allocnodes"] = allocnodes.group(1)
        # Get allocated CPUs
        alloccpus = re.search(r"cpu=([0-9]+)", d["alloctres"])
        if not alloccpus:
            d["alloccpus"] = "??"
        else:
            d["alloccpus"] = alloccpus.group(1)
        # Get allocated memory (may be in varying units)
        allocmem = re.search(r"mem=([0-9]+.[0-9]+[A-Z]|[0-9]+[A-Z])", d["alloctres"])
        if not allocmem:
            d["allocmem"] = "??"
        else:
            d["allocmem"] = allocmem.group(1)
        # Get allocated GPUs
        allocgpus = re.search(r"gres/gpu=([0-9]+)", d["alloctres"])
        if not allocgpus:
            d["allocgpus"] = "0"
            d["allocgpumodels"] = "--"
            d["allocgpustr"] = d["allocgpus"]
        else:
            d["allocgpus"] = allocgpus.group(1)
            # Get allocated GPU models (typically one but could be multiple)
            allocgpumodels = re.findall(r"gres/gpu:([a-zA-Z0-9]+)", d["alloctres"])
            if not allocgpumodels:
                d["allocgpumodels"] = "--"
                d["allocgpustr"] = d["allocgpus"]
            else:
                d["allocgpumodels"] = ",".join(allocgpumodels)
                d["allocgpustr"] = d["allocgpus"] + " (" + d["allocgpumodels"] + ")"
    # Calculate CPU efficiency
    d["cpueff"] = cpueff(d["totalcpu"], d["cputime"])
    # Calculate user CPU %
    d["usercpupct"] = cpupct(d["usercpu"], d["totalcpu"])
    # Calculate system CPU %
    d["systemcpupct"] = cpupct(d["systemcpu"], d["totalcpu"])
    # Derive maxmem, maxdiskread, and maxdiskwrite depending on job state
    # If job is RUNNING and user or root, use sstat values
    if "RUNNING" in d["state"] and (d["user"] == os.environ["USER"] or os.getuid() == 0):
        sstatv = getsstatv(d["jobid"])
        d["tresusageintot"] = sstatv["tresusageintot"]
        d["tresusageouttot"] = sstatv["tresusageouttot"]
    # tresusage values may be empty
    # If job is PENDING or CANCELLED/FAILED before job started
    # If job is RUNNING but not user or root
    # Derive max memory used from tresusageintot
    allmem = re.findall(r",mem=([0-9]+.[0-9]+[A-Z]|[0-9]+[A-Z])", d["tresusageintot"])
    if not allmem:
        d["maxmem"] = -1.0
    else:
        allmembytes = [tobytes(mem) for mem in allmem]
        d["maxmem"] = max(allmembytes)
    # Derive max disk read from tresusageintot (already in bytes)
    alldiskread = re.findall(r"disk=([0-9]+)", d["tresusageintot"])
    if not alldiskread:
        d["maxdiskread"] = -1.0
    else:
        alldiskread2 = [int(dr) for dr in alldiskread]
        d["maxdiskread"] = max(alldiskread2)
    # Derive max disk write from tresusageouttot (already in bytes)
    alldiskwrite = re.findall(r"disk=([0-9]+)", d["tresusageouttot"])
    if not alldiskwrite:
        d["maxdiskwrite"] = -1.0
    else:
        alldiskwrite2 = [int(dw) for dw in alldiskwrite]
        d["maxdiskwrite"] = max(alldiskwrite2)
    d["maxmemfmt"] = fmtmaxbytes(d["maxmem"])
    d["maxdiskreadfmt"] = fmtmaxbytes(d["maxdiskread"])
    d["maxdiskwritefmt"] = fmtmaxbytes(d["maxdiskwrite"])
    # Calculate memory efficiency
    d["memeff"] = memeff(d["maxmem"], d["allocmem"])
    return d

# Define main function to get job info

def getjobinfo(jobid, fields):
    """
    Get job info values

    # Arguments
    - jobid (str): job ID
    - fields (list): sacct fields to query and associated selector functions

    # Returns
    - dict: key-value pairs for job info
    """
    vals = getsacctv(jobid, fields)
    vals2 = derivev(vals)
    return vals2

# Specify sacct fields to query and associated selector functions

fs = [["jobid", firstv],
      ["jobname", firstv],
      ["user", firstv],
      ["account", firstv],
      ["workdir", firstv],
      ["cluster", firstv],
      ["partition", firstv],
      ["nodelist", firstv],
      ["ntasks", max],
      ["reqtres", firstv],
      ["alloctres", firstv],
      ["state", uniquev],
      ["exitcode", firstv],
      ["submit", firstv],
      ["start", min],
      ["end", maxtime],
      ["planned", firstv],
      ["timelimit", maxtime],
      ["elapsed", firstv],
      ["cputime", firstv],
      ["totalcpu", firstv],
      ["usercpu", firstv],
      ["systemcpu", firstv],
      ["tresusageintot", allv],
      ["tresusageouttot", allv]]

# Run main function to get job info

v = getjobinfo(args.jobid, fs)

# Print table of selected key-value pairs

print("Job ID               | " + v["jobid"])
print("Job Name             | " + v["jobname"])
print("User                 | " + v["user"])
print("Account              | " + v["account"])
print("Working directory    | " + v["workdir"])
print("Cluster              | " + v["cluster"])
print("Partition            | " + v["partition"])
print("State                | " + v["statefmt"])
print("Exit code            | " + v["exitcode"])
if v["statefmt"] == "PENDING" or not v["alloctres"]:
    print("Nodes                | " + v["reqnodes"])
    print("Tasks                | " + v["ntasksfmt"])
    print("CPUs                 | " + v["reqcpus"])
    print("Memory               | " + v["reqmem"])
    print("GPUs                 | " + v["reqgpustr"])
else:
    print("Nodes                | " + v["allocnodes"])
    print("Tasks                | " + v["ntasksfmt"])
    print("CPUs                 | " + v["alloccpus"])
    print("Memory               | " + v["allocmem"])
    print("GPUs                 | " + v["allocgpustr"])
print("Nodelist             | " + v["nodelist"])
print("Submit time          | " + v["submit"])
print("Start time           | " + v["startfmt"])
print("End time             | " + v["endfmt"])
print("Wait time            | " + v["planned"])
print("Reserved walltime    | " + v["timelimit"])
print("Elapsed walltime     | " + v["elapsedfmt"])
print("Elapsed CPU walltime | " + v["cputimefmt"])
print("Used CPU time        | " + v["totalcpufmt"])
print("CPU efficiency       | " + v["cpueff"])
print("% User (computation) | " + v["usercpupct"])
print("% System (I/O)       | " + v["systemcpupct"])
print("Max memory used      | " + v["maxmemfmt"])
print("Memory efficiency    | " + v["memeff"])
print("Max disk read        | " + v["maxdiskreadfmt"])
print("Max disk write       | " + v["maxdiskwritefmt"])
