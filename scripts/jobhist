#!/usr/bin/env python3

"""
jobhist

View compact history of jobs

This script requires:
  - Python 3.10+ (for the zip() strict = True option)
  - Slurm (any recent version should work)
  - Slurm configured with:
    - JobAcctGatherType=jobacct_gather/linux or jobacct_gather/cgroup

Notes:
  - Based on output from sacct
  - Default time period is past day
  - State filter is based on current job state
"""

from datetime import datetime, timedelta
import argparse
import os
import re
import subprocess
import sys

# Set up arguments and options ###########################################################

parser = argparse.ArgumentParser(
    prog = "jobhist",
    formatter_class = argparse.RawDescriptionHelpFormatter,
    description = "View compact history of jobs",
    epilog = """\
examples:

jobhist
jobhist --me
jobhist -s 2024-07-01
jobhist -s 2024-07-01 -e 2024-07-02
jobhist -u ttrojan
jobhist -p largemem
jobhist -u ttrojan -p main
jobhist -u ttrojan -s 2024-07-01 -p gpu
jobhist -a ttrojan_123
jobhist -n sim2
jobhist -w a01-[01-20]
jobhist -t failed

notes:

default time period is past day
state filter is based on current job state
to view more job details, run jobinfo <jobid>

support:

https://github.com/uschpc/slurm-tools/issues"""
)
parser.add_argument(
    "-a",
    "--account",
    help = "account to query for history (comma-separated list)"
)
parser.add_argument(
    "-e",
    "--end",
    help = "end date to query for history (YYYY-MM-DD)"
)
parser.add_argument(
    "--me",
    action = "store_true",
    help = "query own jobs"
)
parser.add_argument(
    "-n",
    "--name",
    help = "job name (partial or full) to query for history (comma-separated list)"
)
parser.add_argument(
    "-w",
    "--nodelist",
    help = "node list to query for history (range or comma-separated list)"
)
parser.add_argument(
    "-p",
    "--partition",
    help = "partition to query for history (comma-separated list)"
)
parser.add_argument(
    "-q",
    "--qos",
    help = "QOS to query for history (comma-separated list)"
)
parser.add_argument(
    "-r",
    "--reason",
    help = "last pending reason to query for history (excluding resources and priority) (comma-separated list)"
)
parser.add_argument(
    "-s",
    "--start",
    help = "start date to query for history (YYYY-MM-DD)"
)
parser.add_argument(
    "-t",
    "--state",
    help = "current job state to query for history (comma-separated list)"
)
parser.add_argument(
    "-u",
    "--user",
    help = "user to query for history (comma-separated list)"
)
parser.add_argument(
    "-V",
    "--version",
    action = "store_true",
    help = "print version"
)
args = parser.parse_args()

if args.version:
    print("jobhist 2.4.0")
    sys.exit(0)

# Define functions #######################################################################

def memtogib(mem):
    """
    Convert memory value to GiB

    # Arguments
    - mem (str): memory value

    # Returns
    - str: memory value in GiB
    - str: "??" if unit not found
    """
    m = float(mem[:-1])
    if mem.endswith("T"):
        return str(int(m * 1024)) + "G"
    if mem.endswith("G"):
        return str(int(m)) + "G"
    if mem.endswith("M"):
        return str(int(m / 1024)) + "G"
    if mem.endswith("K"):
        return str(int(m / 1024**2)) + "G"
    if mem[-1].isdigit():
        return str(int(mem / 1024**3)) + "G"
    return "??"

def derivev(fields, values):
    """
    Derive job info values from sacct values

    # Arguments
    - fields (str): job info fields used for sacct -o
    - values (list): job info values from sacct -X -p output

    # Returns
    - dict: job info key-value pairs

    # Notes
    - Assumes sacct -X -p -o options are used
    - Assumes sacct state,reqtres,alloctres fields are present
    """
    # Create dict from keys and values
    keys = fields.split(",")
    d = dict(zip(keys, values, strict = True))
    # Replace state CANCELLED by ... with just CANCELLED
    if "CANCELLED" in d["state"]:
        d["state"] = "CANCELLED"
    # Get requested nodes
    reqnodes = re.search(r"node=([0-9]+)", d["reqtres"])
    if not reqnodes:
        d["reqnodes"] = "??"
    else:
        d["reqnodes"] = reqnodes.group(1)
    # Get requested CPUs
    reqcpus = re.search(r"cpu=([0-9]+)", d["reqtres"])
    if not reqcpus:
        d["reqcpus"] = "??"
    else:
        d["reqcpus"] = reqcpus.group(1)
    # Get requested memory (may be in varying units)
    reqmem = re.search(r"mem=([0-9]+.[0-9]+[A-Z]|[0-9]+[A-Z])", d["reqtres"])
    if not reqmem:
        d["reqmem"] = "??"
    else:
        d["reqmem"] = memtogib(reqmem.group(1))
    # alloctres is empty if resources have not been allocated
    # If job is PENDING or CANCELLED/FAILED before job started
    if not d["alloctres"]:
        d["allocnodes"] = "--"
        d["alloccpus"] = "--"
        d["allocmem"] = "--"
    else:
        # Get allocated nodes
        allocnodes = re.search(r"node=([0-9]+)", d["alloctres"])
        if not allocnodes:
            d["allocnodes"] = "??"
        else:
            d["allocnodes"] = allocnodes.group(1)
        # Get allocated CPUs
        alloccpus = re.search(r"cpu=([0-9]+)", d["alloctres"])
        if not alloccpus:
            d["alloccpus"] = "??"
        else:
            d["alloccpus"] = alloccpus.group(1)
        # Get allocated memory (may be in varying units)
        allocmem = re.search(r"mem=([0-9]+.[0-9]+[A-Z]|[0-9]+[A-Z])", d["alloctres"])
        if not allocmem:
            d["allocmem"] = "??"
        else:
            d["allocmem"] = memtogib(allocmem.group(1))
    return d

# Get sacct values #######################################################################

# Specify sacct fields to query
fs = "jobid,start,user,jobname,partition,state,elapsed,reqtres,alloctres"

# Derive sacct command based on given arguments
cmd = ["sacct", "-a", "-X", "-n", "-p", "-o", fs]
tday = datetime.today()
yday = tday - timedelta(days = 1)
tday = tday.strftime("%Y-%m-%dT%H:%M:%S")
yday = yday.strftime("%Y-%m-%d")
if args.start and args.end:
    cmd = cmd + ["-S", args.start, "-E", args.end]
elif args.start and not args.end:
    cmd = cmd + ["-S", args.start, "-E", tday]
elif not args.start and args.end:
    print("Error: no start date given", file = sys.stderr)
    sys.exit(1)
else:
    cmd = cmd + ["-S", yday, "-E", tday]
if args.account:
    cmd = cmd + ["-A", args.account]
if args.me:
    cmd = cmd + ["-u", os.environ["USER"]]
if args.nodelist:
    cmd = cmd + ["-N", args.nodelist]
if args.partition:
    cmd = cmd + ["-r", args.partition]
if args.qos:
    cmd = cmd + ["-q", args.qos]
if args.reason:
    cmd = cmd + ["--reason", args.reason]
if args.user:
    cmd = cmd + ["-u", args.user]

# Run sacct command and capture output
proc = subprocess.run(cmd, env = {"SLURM_TIME_FORMAT":"%Y-%m-%d"}, capture_output = True, text = True)
if not proc.stdout:
    print("No jobs found")
    sys.exit(0)

# Job names may contain \n (causing line break)
# So splitting by \n does not necessarily split output by line
# First remove all \n and split by |, then group line values using number of fields
out = re.sub(r"\n", "", proc.stdout)[:-1]
out2 = out.split("|")
n = len(fs.split(","))
joblist = [out2[i:i + n] for i in range(0, len(out2), n)]

# Filter by job name using partial or full match
if args.name:
    names = args.name.replace(",", "|")
    joblist = [job for job in joblist if re.search(names, job[3])]

# sacct filters job state over the given time period, which could be multiple states
# Filter based on current job state instead
if args.state:
    states = args.state.upper().replace(",", "|")
    joblist = [job for job in joblist if re.search(states, job[5])]

# Exit if no jobs found after filters
if not joblist:
    print("No jobs found")
    sys.exit(0)

# Process sacct values and print results #################################################

print("----------------------------------------------------------------------------------------------------")
print("Job ID         Startdate       User     Job Name  Partition      State     Elapsed Nodes CPUs Memory")
print("------------- ---------- ---------- ------------ ---------- ---------- ----------- ----- ---- ------")
for job in joblist:
    v = derivev(fs, job)
    # Print requested resources in some cases
    if (v["state"] == "PENDING"
        # If job is CANCELLED before resources are allocated
        or (v["state"] == "CANCELLED" and v["alloctres"] == "")
        # If job submission FAILED (e.g., requested node configuration is not available)
        or (v["state"] == "FAILED" and v["start"] == "None")):
        print(f"{v['jobid'][:13]:<13}" + " " +
              f"{v['start'][:10]:>10}" + " " +
              f"{v['user'][:10]:>10}" + " " +
              f"{v['jobname'][:12].strip():>12}" + " " +
              f"{v['partition'][:10]:>10}" + " " +
              f"{v['state'][:10]:>10}" + " " +
              f"{v['elapsed'][:11]:>11}" + " " +
              f"{v['reqnodes'][:5]:>5}" + " " +
              f"{v['reqcpus'][:4]:>4}" + " " +
              f"{v['reqmem'][:6]:>6}")
    # Print allocated resources in all other cases
    else:
        print(f"{v['jobid'][:13]:<13}" + " " +
              f"{v['start'][:10]:>10}" + " " +
              f"{v['user'][:10]:>10}" + " " +
              f"{v['jobname'][:12].strip():>12}" + " " +
              f"{v['partition'][:10]:>10}" + " " +
              f"{v['state'][:10].strip():>10}" + " " +
              f"{v['elapsed'][:11]:>11}" + " " +
              f"{v['allocnodes'][:5]:>5}" + " " +
              f"{v['alloccpus'][:4]:>4}" + " " +
              f"{v['allocmem'][:6]:>6}")
